\documentclass[12pt, a4paper]{article}
%\documentclass[12pt,openright,oneside,a4paper,english,brazil]{abntex2}

\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,latexsym}
\usepackage{amsthm}
\usepackage{amstext}
\usepackage{multicol}
\usepackage{qtree}
\usepackage{mathtools}
\usepackage{cite}
\usepackage[nottoc,notlot,notlof]{tocbibind}
\usepackage{ mathrsfs }

\usepackage[hidelinks]{hyperref}
\usepackage{xcolor}
\hypersetup{
colorlinks,
linkcolor={blue!50!green},
citecolor={blue!50!black},
urlcolor={blue!80!black}
}

\newtheorem*{theorem}{Theorem}

\author{Yuri A. Martins}
\title{Fundamentos Matemáticos da Computação II}


\begin{document}

\begin{titlepage}
\begin{center}
{\large Universidade Federal do Rio Grande do Norte}\\[0.2cm]
{\large Instituto Metrópole Digital}\\[0.2cm]
{\large Bacharelado em Tecnologia da Informação}\\[0.2cm]
{\large Fundamentos Matemáticos da Computação II}\\[5.1cm]
{\bf \huge Estudo dirigido do conteúdo da Unidade 2}\\[5.1cm]
\end{center}
{\large Autor: Yuri Alessandro Martins}\\[0.7cm]
\begin{center}
{\large Natal/RN}\\[0.2cm]
{\large \today}
\end{center}
\end{titlepage}

\begin{center}
\large \textbf{O que é esse documento?}
\end{center}

Esse é um documento que visa resumir o conteúdo apresentado em sala de aula na disciplina \textbf{Fundamentos Matemáticos da Computação} da \textbf{Universidade Federal do Rio Grande do Norte}, durante o descorrer da segunda unidade, matéria essa da grade curricular do curso de \textbf{Bacharelado em Tecnologia da Informação}. 

Tenha em vista que esse documento não server como base concreta/completa de estudo. Ele, na verdade, visa resumir e direcionar o estudo da disciplina. Dessa forma, cabe ao aluno buscar formas complementares de entender o que está sendo dito aqui, como, por exemplo, o material referência utilizado.

Saiba também que esse é um material \textit{open-source}, que pode ter sido alterado por diversas pessoas (você pode conferir isso em \ref{sec:colaboracao} - Política de Colaboração), e portanto pode não refletir um conteúdo totalmente ``padronizado''.


\clearpage

\tableofcontents
\clearpage

\section{Teoria dos Conjuntos}

\subsection{Os Axiomas de Zermelo-Frankel}
\subsubsection{Extensionalidade}
\label{sec:extensionalidade}
Para quaisquer conjuntos $A, B$:\\
\begin{center}
$ A = B ~ \iff ~ (\forall x ) (x \in A ~ \iff ~ x \in B) $
\end{center}
\subsubsection{Emptyset}
\label{sec:emptyset}
Garante que existe um conjunto vazio ($\emptyset$). \\
\begin{center}
$ \exists x \forall y ~ (y~\notin~x) $
\end{center}
\subsubsection{Pairset}
Para todo $a$ e $b$, existe o conjunto $\{a,b\}$.\\
\begin{center}
$ {\forall a} {\forall b} ~ {\exists w} {\forall x} (x \in w ~ \iff ~ x = a ~\vee~ x = b ) $
\end{center}
\subsubsection{Separation}
\label{sec:separation}
Para cada condição $P(x)$,\\
\begin{center}
$ \forall a \exists w \forall x (x \in w ~ \iff ~ x \in a ~\wedge~ P(x) )$
\end{center}

Um problema de usar somente esses últimos três axiomas é que só somos capazes de formar
conjuntos com cardinalidade $\leq$ 2.
\begin{itemize}
\item ZF4 (\ref{sec:separation}) é um  \underline{axiom-scheme}. Isto é, possui infinitos axiomas dentro dele, já que
para cada P(x) estamos formando um novo axioma.
\end{itemize}

\begin{description}
\item[-] Usando os axiomas anteriores, é possível representarmos algumas coisas como conjuntos:
\begin{itemize}
\item (x, y) $\triangleq$ \{ \{x\}, \{x, y\}\}	\label{teste}
\item A $\setminus$ B $\triangleq$ \{ x $\in$ A ~$\mid$~ x $\notin$ B \}
\item $ A \cap B \triangleq \{ x \in A \mid x \in B \} $
\end{itemize}
\end{description}

\subsubsection{Powerset $\wp$}
Para cada conjunto $a$, existe um conjunto $b$, onde os elementos de $b$ são subconjuntos de $a$.
\begin{center}
$\forall a \exists p \forall b ( b \in p ~ \iff ~ \forall x (x \in a \implies x \in b))$
\end{center}

Esse é o conjunto $\wp$(a).

Aqui $x \in a$ é uma abreviação de $(\forall t)[t \in x \implies t \in a]$. O Axioma da Extensionalidade (\ref{sec:extensionalidade}) implica que para cada a, apenas um conjunto b pode satisfazer a defininção do Powerset; Nós podemos chamar \textbf{Conjunto Potência} de a e denotá-lo como:\\
$\wp(a) \triangleq \{x \mid Set(x) \& x \subseteq a \}$\\

Algumas propriedades interesantes:\\
$\wp$($\emptyset$) = $\{ \emptyset \}$ \\
$\wp$($\{ \emptyset \} $) = $\{ \emptyset \ , \{ \emptyset \}\}$\\

Exercício: Para cada conjunto $A$, existe um conjunto $B$ cujo membros são exatamente singletons dos membros de $A$:
\begin{center}
$ x \in B \iff (\exists t \in A) [x = \{t\}]$
\end{center}
\subsubsection{Unionset}
\label{sec:unionset}
Corresponde ao conjunto $\cup a$.\\
\begin{center}
$\forall a \exists u \forall x ( x \in u ~\iff~ (\exists e \in a) [x \in e] )$
\end{center}

Ex: $\cup \emptyset = \cup \{ \emptyset \} = \emptyset$

\begin{itemize}
\item $a \cup b = \cup \{a,b\}$

Usando os axiomas ZF2 (\ref{sec:emptyset}) e ZF5 (\ref{sec:unionset})\\
\begin{center}
$t \in A \cup B \iff (\exists X \in \{A,B\})[t \in X]$\\
$t \in A \cup B \iff t \in A \vee t \in B$
\end{center}
\item $ a \times b \triangleq \{ w \in S \mid \exists x \exists y (w = (x,y) \land x \in a \land x \in b)\}$ \\
Onde $S = \wp(\wp(a \cup b))$
\item sigletonset $ \triangleq \{ x ~ \in ~ \wp a ~\mid~ (\exists t ~\in~ a)[x = \{t\}]\}$
\item $\cap a \triangleq \{x ~\in~ \cup a ~\mid~ (\forall e ~\in~ a)[x ~\in~ e]\}$
\end{itemize}

\subsubsection{Infinity Axiom}
\label{sec:infinity}
$\exists I (\emptyset ~\in~ I ~\land~ \forall x (x ~\in~ I \implies \{x\} ~\in~ I ))$ ou\\
$\exists I (\emptyset ~\in~ I ~\land~ \forall x (x ~\in~ I \implies x ~\cup~ \{x\} ~\in~ I ))$\\

Esse axioma é garantido pois\\
\begin{align*}
\{x\} &\ne x \\
x \cup \{x\} &\ne x
\end{align*}

Com ele, somos capazes de montar os seguintes conjuntos:
\begin{flalign*}
I &= \{ \emptyset, \{\emptyset\}, \{\{\emptyset\}\}, \cdots \} & ~ou \\
I &= \{ \emptyset, \{\emptyset\}, \{\{\emptyset\}\}, \cdots \} &
\end{flalign*}

\subsubsection{Definindo um par ordenado}
Consideraremos primeiro a operação básica de par (ordenado). Intuitivamente, o par $(x,y)$ de dois objetos $x$ e $y$ é a ``coisa'' que tem o ``primeiro membro'' $x$ e o ``segundo membro'' $y$, e é diferente do par não-ordenado $\{x,y\}$ desde que (por exemplo) $\{0,1\} = \{1,0\}$ enquanto $(0,1) \neq (1,0)$. Assim, a primeira caracteristica de um par ordenado seria:
\begin{align*}
(x,y) = (x^\prime ,y^\prime) &\iff x = x^\prime ~\&~ y = y^\prime && (OP1)
\end{align*}  

Existe um segundo, provavelmente uma propriedade caracteristica dos pares menos óbvia, que torna possível definir Produtos Cartesianos: para dois conjunto $A$ e $B$:

\begin{align*}
\text{A classe } A \times B &=_\text{df} \{(x,y) \mid x \in A ~\&~ y \in B\} \text{é conjunto.} && (OP2)
\end{align*}

Então, o problema de representar a noção de ``par'' na teoria dos conjunto é que: é preciso definir uma operação $(x,y)$, tal que OP1 e OP2 respeitam os axiomas de Zermelo.

A operação de par do \textbf{Kuratowski}\footnote{Como vimos anteriormente, apenas exemplificando como um Axioma da Separação poderia ser utilizado, na seção~\ref{sec:separation}.}:
\begin{align*}
(x, y) = \{ \{x\}, \{x, y\}\} && \text{Respeita OP1 e OP2}\\
\end{align*}

\begin{proof}
(OP1) Provando a direção $\implies$\footnote{A direção oposta é muito trivial, segundo \cite{moschovakis2006notes}}, vamos distinguir dois casos.\\

Se $x = y$, então $\{x,y\} = \{x, x\} = \{x\}$, o conjunto $(x,x) = \{\{x\},\{x\}\} = \{\{x\}\}$ é um singleton, consequentemente o conjunto $(x^\prime, y^\prime)$ , que se presume ser igual a ele também é um singleton, de modo que $x^\prime = y^\prime$ e $(x^\prime, y^\prime) = \{\{ x^\prime \}\}$; e desde que este último singleton seja igual a $\{\{x\}\}$, nos temos $x = x^\prime$, consequentemente, também $y = x = x^\prime = y^\prime$.

Agora, se $x \neq y$, então os membros de $(x,y)$ são singletons de $\{ x\}$ e o doubleton $\{x,y\}$, e estes devem corresponder aos membros $\{x^\prime \}$ e $\{ x^\prime, y^\prime \}$ do conjunto $(x^\prime, y^\prime)$, e que nos devemos ter $\{x\} = \{x^\prime \}, \{x,y\} = \{x^\prime, y^\prime \}$, e, então, imediatamente, $x = x^\prime$ e $y = y^\prime$.

(OP2) É suficiente provar que para dois conjunto $A$ e $B$, existe um conjunto $C$ tal que:
\begin{align*}
x \in A ~\&~ y \in B \implies \{\{x\}, \{x,y\}\} \in C
\end{align*}

Porque então:
\begin{align*}
A \times B = \{z \in C \mid (\exists x \in A)(\exists y \in B)[z = (x,y)\}
\end{align*}

Seguindo pelo $x$:
\begin{align*}
x \in A, y \in B &\implies \{x\}, \{x,y\} \subseteq  (A \cup B)\\
				&\implies \{x\}, \{x,y\} \in \wp(A \vee B)\\
				&\implies \{\{x\}, \{x,y\}\} \subseteq \wp(A \cup B)\\
				&\implies \{\{x\}, \{x,y\}\} \in \wp (\wp (A \cup B))
\end{align*}
então nós podemos ter $C = \wp \wp (A \cup B)$.
\end{proof}

Nós agora definimos a operação $(x,y)$ que satisfaz (\textbf{OP1}) e (\textbf{OP2}), talvez o \textbf{Kuratowski}, provado anteriormente, ou talvez algum outro: não importa mais a definição escolhida, a única coisa que conta é a operação de par que satisfaça (\textbf{OP1}) e (\textbf{OP2})

\subsubsection{União Disjunta}

\begin{itemize}
\item[-] União Disjunta: $A \uplus B = (\{0,a\} \times A) \cup (\{1,b\} \times B)$
\end{itemize}

\subsection{Relações e Funções Parciais}

\subsubsection{Relações}

Def: Sejam $A,B$ conjuntos, $R$ é uma relação \underline{entre} $A$ e $B$ se $R \subseteq A \times B$.

Dessa forma,
\begin{itemize}
\item $f(a) = b \leadsto (a,b) \in f$
\end{itemize}

Sendo $R$ uma relação sobre o conjunto $\mathbb{N} (R \subseteq A \times A), R$ pode ser:

\begin{align*}
x R x &: Reflexiva \leadsto `` =, ~\leq, ~\geq, ~\subseteq ''\\
x R y \implies  y R x  &: Simetrica \leadsto `` =  ''\\
x R y \land y R z \implies x R z &: Transitiva \leadsto  `` =, ~\leq, ~\geq, ~<, ~>, ~\subseteq ''
\end{align*}

Ainda existem outras propriedas como essas, como a \underline{Antireflexiva} ou \underline{Antisimétrica}.

\subsubsection{Relações de Equivalência}
Uma relação sobre um conjunto $A$ é chamada \textbf{relação de equivalência} se ela for \underline{reflexiva},
\underline{simétrica} e \underline{transitiva}.

O conjunto de todos os elementos que são relacionados a um elemento $a$ de $A$ é chamado de \underline{classe de equivalência} de $a$. Isso implica que:
\begin{center}
$\cup [a] = A$
\end{center}

\begin{itemize}
\item $[a] \cap [b] = \emptyset ~quando~ [a]~ \neq[b]$\\
\end{itemize}

Uma partição de um conjunto $S$ é uma coleção de subconjuntos disjuntos não vazios de $S$. A união de todas as partições resulta, portanto, em $S$. Em outras palavras, os subconjuntos $A_i$ formam partições de $S$ se e somente se\\
\begin{align*}
A_i &\neq \emptyset\\
A_i &\cap A_j = \emptyset, quando~i \neq j\\
\cap A_i &= S
\end{align*}

Podemos definir classes de equivalência como:\\
\begin{align*}
[x/\backsim] &\triangleq \{a \in A \mid x \backsim a \}\\
[A/\backsim] &\triangleq \{c \in \wp(A) \mid \exists x ~ C = [x/\backsim] \}
\end{align*}

Seja $x,y \in A$, e $\backsim$ uma relação de equivalência no $A$:
\begin{align*}
[x/\backsim] = [y/\backsim] &\iff x \backsim y\\
[x/\backsim] = [y/\backsim] &\iff
\begin{cases}
[x/\backsim] 	& \text{se } x \backsim y \\
\emptyset 		& \text{se não}\\
\end{cases}
\\
\cup\{[x/ \backsim] \mid x \in a \} &= A
\end{align*}

\subsubsection{Funções parciais na ZFC}
O conceito de funções parciais remete a ideia de uma função em que nem todos os $x$ possuem uma $f(x)$ (Usaremos a notação $\rightharpoonup$).
\begin{align*}
f: \mathbb{N} \rightharpoonup  \mathbb{N} && \text{Domínio da função}\\
f(x) = \sqrt[2]{x} && x = 3 \text{ não possui uma saída bem definida nesse domínio.}
\end{align*}

\subsection{Currying}
Dada uma $f$ do tipo $f:(X \times X) \rightarrow Z$, então a técnica de \textbf{currying} a torna $(f): X \rightarrow (Y \rightarrow Z)$.
Isto é, currying torna um paramêtro do tipo $X$ e retorna uma função do tipo $Y \rightarrow Z$.\\


\noindent Achar um $\phi ( (x,y) \rightarrow A \rightarrowtail\!\!\!\!\!\rightarrow (x \rightarrow (y \rightarrow A)))$\\
$\phi(F) = G$, onde $G$ é definida pela,\\
$G(x)(y) = g$, onde $g$ é definida pela,\\
$g(y), f(x,y)$

\subsection{Cardinais}
Seja $A$ um conjunto. O que é $|A|$?
\begin{itemize}
\item[c1.] $A =_c |A|$
\item[c2.] $A =_c B \iff |A| = |B|$
\item[c3.] para todo conjunto de conjuntos $\epsilon$,\\
$\{|x| \mid x \in \epsilon \}$ é conjunto.
\end{itemize}

\subsubsection{Números Cardinais}
Uma (fraca) \textbf{atribuição de cardinalidade} é qualquer operação definida nos conjuntos $A \mapsto |A|$ que satisfaz (c1) e (c3). Uma \textbf{atribuição de cardinal forte} também satisfaz o (c2). Iremos utilizar a definição \textbf{fraca}, que pode ser ajustada ao (c2) como:\\
\begin{itemize}
\item[c2.] $A =_c B \iff |A| =_c |B|$
\end{itemize}

Os \textbf{números cardinais} (relativo a uma dada atribuição de cardinalidade) são os valores:
\begin{align*}
\text{Card}(\kappa) \iff \kappa \in \text{Card } \iff_\text{df } (\exists A)[\kappa = |A|]
\end{align*}

Vamos definir uma especifica (provavelmente fraca) atribuição de cardinalidade e vamos definir as operações aritiméticas nos cardinais como:
Sejam $\kappa, \lambda, \mu$ números cardinais:
\begin{align*}
\kappa + \lambda &\triangleq_c \kappa \uplus \lambda & \\
\kappa . \lambda &\triangleq_c \kappa \times \lambda & \\
\kappa^\lambda &\triangleq_c (\kappa \to \lambda) &
\end{align*}

Atente ao fato que existe apenas uma escolha para $|\emptyset|$,
\begin{align*}
0 =_\text{df} |\emptyset| = \emptyset
\end{align*}

uma vez que apenas $|\emptyset| = \emptyset$ satisfaz $\emptyset =_c |\emptyset|$. Isso é também conveniente para o conjunto:
\begin{align*}
1 ~=_\text{df} |\{\emptyset\}|, ~2 ~=_\text{df} |\{0,1\}|
\end{align*} 

\subsection{Os Axiomas de Peano}
\textbf{Structed set}: $(\mathbb{N}; 0; S)$, onde $0 \in \mathbb{N}$ e $S:\mathbb{N} \rightarrow \mathbb{N}$
\begin{align*}
0 &\in \mathbb{N}\\
S: \mathbb{N} &\rightarrow \mathbb{N}\\
S: \mathbb{N} &\rightarrowtail \mathbb{N}\\
(\forall x \in \mathbb{N})&[S_n \neq 0 ]\\
(\forall x \subseteq \mathbb{N})&[ [0 \in X \land (\forall n \in \mathbb{N}) [n \in X \implies S_n \in X ]] \implies X = \mathbb{N}]
\end{align*}

O axioma de peano 5 é o que nos permite realizar indução matemática. Observe:
\begin{align*}
\forall x \subseteq \mathbb{N}~&corresponde~a~\textbf{base}.\\
(\forall n \in \mathbb{N}) [n \in X \implies S_n \in X] ~&corresponde~ao~\textbf{passo indutivo}.\\
n \in X ~&corresponde~a~\textbf{hipotése indutiva}.
\end{align*}

\subsection{Teorema da Recursão}
\label{sec:recursion}
\begin{theorem}
Sejam: $(\mathbb{N}, 0, S)$ um sistema de naturais conjunto E.\\
$a \in E$\\
$h:E \rightarrow E$\\
Então existe $f: \mathbb{N} \rightarrow E$\\
tal que: $f(0) = a e f(S_n) = h(f(n))$.
\end{theorem}

Agora, precisamos provar que $f$ existe e é bem definida no domínio escolhido.

\begin{proof}

\begin{flalign*}
\text{Sendo } f_0 &\triangleq \{0\} \to E & && f_0~:~\{\emptyset\} \to E & \\
\text{Sendo } f_1 &\triangleq \{(0,a)\} \to E & && f_1~:~\{0,1\} \to E\\
\text{Sendo } f_2 &\triangleq \{(0,a), (1,h(a))\} & && f_2~:~\{0,1,2\} \to E\\
&\vdots&\\
f &\triangleq \bigcup_i ~ f_i
\end{flalign*}
\begin{flalign*}
p \in \mathscr{A} &\iff\\
					&\text{Function}(p)\\
					&\land \text{domain}(p)\\
					&\land \text{image}(p)\\
					&\land 0 \in \text{ domain}(p)\\
					&\land p(0) = a\\
					&\land S_n \in \text{ domain}(p) \implies (n \in \text{ domain}(p) \land p(S_n) = h(p(n)))
\end{flalign*}

Seja $f = \bigcup \mathscr{A}$\\

Para confirmar que $f$ é uma função:\\
$p_1 ~\&~ q \in \mathscr{A}$\\
$n \in $ domain$(p)~ \cap$ domain($q) \implies p(n) = q(n)$ \\

\begin{flalign*}
BASE:~ 0 \in ~\text{domain}(p)~ &\land ~\text{domain}(p)~ \implies p(0) = q(0) & \\
p(0) = ~&a = q(0) & && (\text{def de } \mathscr{A})\\
H.P:~ n \in \text{domain}(p) &\land \text{ domain}(q) \implies p(n) = q(n)\\
P.I:~ S_n \in \text{domain}(p) &\land \text{domain}(q) \implies p(S_n) = q(S_n)\\
\text{Suponha } S_n \in \text{domain}(p) &\land \text{domain}(q):\\
p(S_n) &= h(p(n)) & && (p \in \mathscr{A})\\
		&= h(q(n)) & && (\text{H.I})(\text{def de } \mathscr{A})  \\
		&= q(S_n) & && (\text{def de } \mathscr{A})\\
\end{flalign*}

Agora que domain($f) = \mathbb{N}$
\begin{align*}
0 \in \text{domain}(f)\\
n \in \text{domain}(f) \implies S_n \in \text{ domain}(f)
\end{align*}
\end{proof}
... Certamente para ser melhorado depois!

\subsection{Os Naturais na ZFC}
Para estabelecermos os Naturais na ZFC, temos que garantir duas coisas:
\begin{itemize}
\item Existência de $\mathbb{N}$
\item Singularidade de $\mathbb{N}$
\end{itemize}

Para tal, iremos precisar do Teorema da Recursão (\ref{sec:recursion}).

\subsubsection{Existência de $\mathbb{N}$} 
O Axioma da Infinidade (\ref{sec:infinity}) garante a exitência de um conjunto $I$ tal que:
\begin{align*}
\emptyset &\in I\\
(\forall n)[n \in I &\implies \{n\} \in I]
\end{align*}
Usando esse $I$, primeiro vamos definir uma família de conjuntos:\\
Seja $\jmath$ = todos os conjuntos $C \subseteq I$ tal que satisfaz o ZF7 (\ref{sec:infinity})\\
$\jmath = \{C \in \wp I \mid \emptyset \in C \land (\forall x \in C)[\lambda x.\{x\} \in C]\}$
\begin{flalign*}
\text{Seja } \mathbb{N} &\triangleq \bigcap \jmath &\\
\text{Seja } 0_1 &= \emptyset&\\
\text{Seja } S_1 &= \lambda x.\{x\}
\end{flalign*}

Primeiro, criamos o $\jmath$ porque o Axioma da Infinidade (\ref{sec:infinity}) não nos garante que existe apenas um $I$, mas que, certamente, existe esse $I$ definido (então, vamos considerar todos os $I$ que existem como $\jmath$). Então, definimos $\mathbb{N} \triangleq \cap \jmath$ porquê assim iremos conseguir ignorar todos os outros conjuntos $I$ dois quais nos não precisamos e iremos manter apenas o que queremos, tendo em vista que todos os $C$ terão o $\emptyset$ e mais alguma coisa (lixo\footnote{Termo não tão apropriado, mas com uma noção interessante se traçarmos um parelelo com linguagem de programação.}), e o nosso $I$ procurado terá apenas $\emptyset$. Dessa forma, o lixo foi ignorado. 

Para terminar a prova, é suficiente provar que $(\mathbb{N}, 0, S)$ é um sistema de Peano. Para começar, $\mathbb{N} \in \jmath$, por que $X \in \jmath \implies \emptyset \in X$ e consequentemente $\emptyset \in \bigcap = \mathbb{N}$.
Encaixando com os Axiomas de Peano:
\begin{enumerate}
\item $(\forall x \in J)[\emptyset \in X]$, então $\emptyset \in \cap J$ e $\emptyset \in \mathbb{N}$
\item Também, pela própria definição de J
\item $a \neq b \iff S_a \neq S_b$ ou $a \neq b \iff \{a\} \neq \{b\}$
\item $\forall x \{x\} \neq \emptyset$
\item Seja $X \subseteq \mathbb{N}$, tal que\\
0 $\in$ X\\
$(\forall x \in X)[S_X \in X]$\\
Seja $n \in \mathbb{N}$\\
$\exists p : x = \{p\}$\\
--> Mesmo que $\{p\} \in \cap J = \mathbb{N}$\\
--> Mesmo que $n \in X$ e $x \geq \mathbb{N}$
\end{enumerate}

Basicamente, podemos descrever $\mathbb{N}$ de duas maneiras agora (dependendo de qual das duas versões do Axioma da Infinidade (\ref{sec:infinity}) você resolveu usar nessa etapa):
\begin{multicols}{2}
\noindent 0 \hspace{4bp} $\emptyset$ = $\emptyset$\\
1 \hspace{4bp} $\{\emptyset\} = \{0\}$\\
2 \hspace{4bp} $\{\{\emptyset\}\} = \{1\}$\\
3 \hspace{4bp} $\{\{\{\emptyset\}\}\} = \{2\}\\$
$\vdots$\\
\hspace{5bp} S = $\lambda$x.$\{x\}$ \\

\noindent 0 \hspace{4bp} $\emptyset$ = $\emptyset$\\
1 \hspace{4bp} $\{\emptyset\} = \{0\}$\\
2 \hspace{4bp} $\{\emptyset, \{\emptyset\}\} = \{0,1\}$\\
3 \hspace{4bp} $\{\emptyset, \{\emptyset\}\, \{\{\emptyset\}\}\}$\\
$\vdots$\\
\hspace{5bp} S = $\lambda x.x \cup \{x\} $
\end{multicols}

\subsubsection{Singularidade de $\mathbb{N}$}
``$\mathbb{N}$ is unique up to isomorphism:''
\begin{align*}
\pi : (\mathbb{N}_1; 0_1; S_1)  &\rightarrowtail\!\!\!\!\!\rightarrow  (\mathbb{N}_1; 0_2; S_2).\\
\hspace{4bp}\pi (0_1) &= 0_2\\
\pi (S_1 n_1) &= S_2 \pi (n_1)
\end{align*}

Se traçarmos um paralelo com o Teorema da Recursão (\ref{sec:recursion}), para tentarmos provar a singularidade de $\mathbb{N}$, podemos realizar as seguintes associações:
\begin{flalign*}
\mathbb{N} &: \mathbb{N}_1\\
E&:~ \mathbb{N}_2 &\\
a&:~ 0_2 &\\
h&:~ S_2 &
\end{flalign*}

\begin{proof}
$\pi : \mathbb{N}_1 \implies \mathbb{N}_2$\\
$\pi[\mathbb{N}_1] = \mathbb{N}_2$
\begin{itemize}
\item $0_2 \in \pi[\mathbb{N}_1]$\\
--> Como $\pi(0_1) \implies S_2n_2 \in \pi[\mathbb{N}_1]$
\item $n_2 \in \pi[\mathbb{N}_1]$\\
--> Suponha que $n_2 \in \pi[\mathbb{N}_1]$ --> H.I\\
--> $(\exists n_1 \in \mathbb{N}_1)[\pi(n_1) = n_2]$\\
--> $\pi(S_1n_1) = S_2(\pi(n_2))$ que $ = S_2n_2$\\
\end{itemize}

... \footnote{Essa prova ainda não está terminada.}

\end{proof}

\subsection{String Recursion}
\begin{itemize}
\item Dado [ ] $\in$ [$\mathbb{N}$]
\item Se $n \in \mathbb{N}$, e $L \in [\mathbb{N}]$, então $(n:L) \in [\mathbb{N}]$
\end{itemize}

Exemplo: 2:3:4:[~~] = [2,3,4]\\

Alguns exemplos de funções recursivas que podemos definir utilizando String Recursion:

\begin{flalign*}
iszero ~:~ [\mathbb{N}] \rightarrow \mathbb{B}\\
iszero~0 &= true&\\
iszero~S_n &= false &
\end{flalign*}

\begin{flalign*}
empty ~:~ [\mathbb{N}] \rightarrow \mathbb{B}\\
empty~[~~] &= true&\\
empty~(x:x_s) &= false&
\end{flalign*}

\begin{flalign*}
++ : [\mathbb{N}] \rightarrow [\mathbb{N}] \rightarrow [\mathbb{N}]\\
[~~] ~ ++ ~ y_s &= y_s&\\
(x:x_s) ~ ++ ~ y_s &= x:(x_s ++ y_s)&
\end{flalign*}

\begin{flalign*}
Ex: [1,2] ++ [6,7,8,9] &= 1:2:[~~] ++ [6,7,8,9]&\\
&= 1:(2:[~~] ++ [6,7,8,9])&\\
&= 1:(2:([~~] ++ [6,7,8,9]))&\\
&= 1:2:[6,7,8,9]&\\
&= [1,2,6,7,8,9]&
\end{flalign*}

\begin{flalign*}
reverse ~:~ [\mathbb{N}] \rightarrow [\mathbb{N}]\\
reverse ~[~~] &= [~~]&\\
reverse ~[x] &= [x]&\\
revese ~(x:x_s) &= reverse xs ++ [x]&
\end{flalign*}

\begin{flalign*}
\sqsubseteq ~:~ [\mathbb{N}] \rightarrow [\mathbb{N}] \rightarrow \mathbb{B}\\
(x:x_s) \sqsubseteq [~~] &= false&\\
'[~~] \sqsubseteq y_s &= true&\\
(x:x_s) \sqsubseteq (y:y_s) &= (x = y) \land xs \sqsubseteq ys&
\end{flalign*}

\begin{flalign*}
Ex: [2,3,4,5] \sqsubseteq [2,3,5,7] &= (2 = 2) \land ([3,4,5] \sqsubseteq [3,5,7])&\\
&= (3 = 3) \land ([4,5] \sqsubseteq [5,7])&\\
&= (4 = 5) \land ([5] \sqsubseteq [7])&\\
&= \text{FALSE}&
\end{flalign*}

\begin{flalign*}
\in ~:~ \mathbb{N} \rightarrow [\mathbb{N}] \rightarrow \mathbb{B}&\\
n \in x ~[~~] &= false&\\
x \in (x:x_s) &= (n = x) \vee (n \in x_s)&
\end{flalign*}

\begin{flalign*}
find : \mathbb{N} \rightarrow [\mathbb{N}] \rightarrow \mathbb{B}\\
find~n~[~~] &= 0&\\
find~n~(n:nx) &= 0&\\
find~n~(x:x_s) &= 1 + find~n~x_s&
\end{flalign*}

\begin{flalign*}
sum~:~[\mathbb{N}] \rightarrow \mathbb{N}&\\
sum [~~] &= 0 & \\
sum (x:xs) &= x + sum xs &
\end{flalign*}

\begin{flalign*}
\oplus~:~[\mathbb{N}] \rightarrow [\mathbb{N}] \rightarrow [\mathbb{N}]\\
'[~~] \oplus y_s &= y_s &\\
x_s \oplus [~~] &= x_s &\\
(x:x_s) \oplus (y:y_s) &= (x+y):(x_s \oplus y_s) &
\end{flalign*}

\begin{flalign*}
circle~:~(\mathbb{N} \rightarrow \mathbb{N} \rightarrow \mathbb{N}) \rightarrow [\mathbb{N}] \rightarrow [\mathbb{N}] \rightarrow [\mathbb{N}]\\
circle~f~[~~]~y_s &= [~~] &\\
f xs [~~] &= [~~] &\\
f~(x:x_s)~(y:y_s) &= [f~x~y]:(circle~f~x_s~y_s) &
\end{flalign*}

\section{$\lambda$-Calculus \cite{wikilambda}}
\label{sec:lambda}
Tomando como base o conteúdo visto em \textbf{Lambda-calculus and combinators}\cite{book:111321} e \textbf{Denotational semantics}\cite{stoy1977denotational}, passamos para a notação de $\lambda$ dando uma sintaxe formal e regras de tranformação sintatíca (conversão). 

\subsection{O conjunto de $\lambda$-termos}
Sendo $\Lambda = \lambda$-termos;
\begin{flalign*}
X &\in \Lambda&\\
s,t &\in \Lambda \implies (s~t) \in \Lambda&\\
x \in var, t \in \Lambda &\implies \lambda X.t \in \Lambda&
\end{flalign*}

\subsection{Conversões $\alpha,~ \beta~ e~ \eta~$}
\subsubsection{Conversão $\alpha$}
Determina que a escolha da variável ligada, na abstração lambda, não importa (normalmente):
\begin{flalign*}
\lambda x.x &=_\alpha \lambda y.y&\\
\lambda x.\lambda x.x &=_\alpha \lambda y.\lambda x.x & && \text{Note que isso não poderá ser transformado em } \lambda y.\lambda x.y
\end{flalign*}

Primeiro, quando alfa-conversão atua em uma abstração, as únicas ocorrências de variáveis que podem ser renomeados são aqueles que são vinculados a esta mesma abstração. No segundo exemplo, portanto:

\begin{flalign*}
\lambda x.\lambda x.x &\not=_\alpha \lambda y.\lambda x.y & &&\text{Este último tem um significado diferente do original.}
\end{flalign*}

Em segundo lugar, uma conversão $\alpha$ não é possível se isto irá resultar em uma variável sendo capturada por uma abstração diferente. Por exemplo, se substituirmos $x$ com $y$ em $\lambda x.\lambda y.x$, nós obteríamos $\lambda y.\lambda y.y$, que tem um significado diferente da expressão anterior.

\subsubsection{Redução $\beta$}
Redução $\beta$ é a ideia de aplicar uma função. Por exemplo, se temos $f(x) = x*2$, para $x = 2$ aplicamos o valor a função que irá ficar como $f(2) = 2*2$. Essa é basicamente a ideia da redução $\beta$.
\begin{flalign*}
(\lambda x.x*2)~2 &=_\beta 2*2 &
\end{flalign*}
\subsubsection{Redução $\eta$}
Eta-conversão expressa a ideia de extensionalidade, que neste contexto é que duas funções são as mesmas se e somente se eles dão o mesmo resultado para todos os argumentos.\footnote{Sujeito a severas mudanças no futuro. Visite \ref{sec:colaboracao} para saber mais sobre.}

\subsection{Booleanos naturais no $\Lambda$}
O $\lambda$-Calculus pode ser usado para modelar valores booleanos, aritmética, estruturas de dados e recursividade. Vamos focar agora em como podemos determinar operadores booleanos em $\lambda$-Calculus:
\begin{align*}
\lambda x.(\lambda y.x) &\coloneqq true \coloneqq fst\\
\lambda x.(\lambda y.y) &\coloneqq false \coloneqq snd
\end{align*}

\textbf{Exercicio:}  Ache $\lambda$-Termos que se comportem como o: 
\begin{itemize}
\item[-] ``not''
\item[-] ``or''
\item[-] ``and''
\end{itemize}

\subsection{Combinadores I, K, B, S \cite{book:111321} e \cite{stenlund2012combinators}}
O sistema de combinadores foi criado para fazer o mesmo trabalho que os sistemas de $\lambda$-Calculus, mas sem o uso de variáveis ligadas. Na verdade, as irritantes complicações técnicas envolvida na substituição e na $\alpha$-conversão vão ser evitadas completamentes a partir daqui. Entretanto, para essa técnica avançada no teremos que sacrificar a clareza intuitiva da notação $\lambda$.

Para motivar combinadores, considere a lei da comutatividade da adição em aritmética, que diz:
\begin{align*}
(\forall x,y)~x+y = y + x
\end{align*}  
A expressão acima contém variáveis ligadas ``$x$'' e ``$y$''. Mas elas podem ser removidas, como a seguir. Nos vamos primeiro definir um operador de adição $A$ por:
\begin{align*}
A(x,y) = x + y && (\text{para todo } x,y)
\end{align*}
e vamos introduzir um operador $C$ definido po:
\begin{align*}
(C(f))(x,y) = f(y,x) && (\text{para todo } f,x,y)
\end{align*}
Então a lei da comutatividade se torna simples
\begin{align*}
A = C(A)
\end{align*}

O operador $C$ pode ser chamado de \textbf{combinador}.

Assuma que é dado uma sequência infinita de expressões $v_0, v_00, v_000, \cdots$ chamadas ``variáveis'', e um finita ou infinita sequencia de expressões chamada ``constantes atômicas'', incluindo três chamadas ``combinadores básicos'': \textbf{I}, \textbf{K} e \textbf{S} (Se \textbf{I}, \textbf{K} e \textbf{S} são as únicas constantes atômicas o sistema será chamado de puro, caso contrário, será aplicado). O conjunto de expressões chamado Termos Lambda é definido por indução como:
\begin{itemize}
\item[(a)] todas as variáveis e constantes atômicas, incluindo \textbf{I}, \textbf{K} e \textbf{S} são Termos Lambda
\item[(b)] se $X$ e $Y$ são Termos Lambda, então é assim $(X,Y)$
\end{itemize}

\begin{flalign*}
K &= \lambda x \lambda y.x & &&\text{Retorna uma contante}\\
B &= \lambda x \lambda y \lambda z . x (yz) & &&\text{``Composition''}\\
I &= \lambda x.x & &&\text{Retorna seu argumento}\\
S &= \lambda x \lambda y  \lambda z. xz(yz) & &&\text{Operador de substituição.}
\end{flalign*}
\textbf{Exercicio}: Mostre que\\
\textbf{-	 $S(KS)K \to B$}:
\begin{flalign*}
(SKK)x &= Kx Kx & && \text{Pela definição de } S\\
		&= x & &&\text{Pela definição de } K \\
		&= I & &&\text{Pela definião de } I
\end{flalign*}
\textbf{- $S(KS)K \to B$}:
\begin{flalign*}
(S(KS)K)xyz &= ((KSx) Kx)yz & &&\text{Pela definição de } S\\
			&= (S Kx)yz & &&\text{ Pela definição de } K\\
			&= (Kxy)(yz) & &&\text{Pela definição de } S\\
			&= x(yz) & &&\text{ Pela definição de } K\\
			&= B & &&\text{ Pela definição de} B.
\end{flalign*}

\section{Política de Colaboração}
\label{sec:colaboracao}
Você é capaz de alterar o conteúdo desse documento, para corrigir erros, melhorar suas explicações ou dar dicas/exemplos adicionais. Esse foi o objetivo desde começo.

\href{https://github.com/YuriAlessandro/BTI-Documents/blob/master/FMC2/fmc2_un2.tex}{Visita a página remota do documento} para obter sua versão mais atualizada e/ou colaborar também.

Como base foram utilizados os livros ``Notes on Set Theory''\cite{moschovakis2006notes} e ``Classic Set Theory''\cite{goldrei1996classic}. Caso você queira continuar usando-os como base para esse documento, sinta-se a vontade. Caso você queira, também, utilizar outras fontes, não deixe de citá-las para que sejam adicionadas as refêrencias. Tenha em mente que outros estudantes podem estar querendo estudar baseado nesse documento, então busque sempre informações confiáveis que podem ser atestadas (por meio da biblografia, por exemplo).

\subsection{Colaboradores}
\begin{itemize}
\item \href{https://github.com/YuriAlessandro}{Yuri Alessandro Martins}
\item \href{http://www.tsouanas.org/}{Thanos Tsouanas}
\item \href{https://github.com/eltonvs}{Elton Viana}
\item Gilney Junior
\end{itemize}
\clearpage
\bibliographystyle{plain}
\bibliography{fmc2_un2_refs}

\end{document}